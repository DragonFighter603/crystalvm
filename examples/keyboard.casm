#SCREEN_BUF_1 0x00000000
#SCREEN_BUF_2 0x0003E800
#TEXT_BUF_1 0x0007D000
#TEXT_BUF_2 0x0007D400

#SCREEN_W 320
#SCREEN_H 200
#TEXT_W 40
#TEXT_H 25

#INTERRUPT 0x0008DE00
#START 0x0008E000

#regids [f'%{id:02X}' for id in range(49)]
#newreg lambda: regids.pop(0)
#dropreg lambda x: (regids.append(x), regids.sort())

~@INTERRUPT
    cmpu %D 0
    jnz @handle
    ret
    #handle $
        pshar

        cmpu %Q 0b0000
        jz @device_connect
        cmpu %Q 0b0001
        jz @finish_handling
        jz %Q 0b0010
        jmp @finish_handling
        ; only 0b0011 left
        jmp @device_disconnect

        #device_connect $
            dread %D @STR_16_BUF 16
            move @STR_16_BUF %20
            move @KEYBOARD_STR %21
            call @STRCMP
            jnz @finish_handling
            move %D @keyboard_id

        #device_disconnect $
            jmp @finish_handling

    #finish_handling $
        resar
        ret

~@START
    #counter newreg()
    #screen_char newreg()
    
    move 0u @counter
    move @TEXT_BUF_1 @screen_char 
    #loop $
        stb @screen_char 65
        addu @screen_char 1 @screen_char
        addu @counter 1 @counter
        
        cmpu @counter 256
        jnz @loop
    #_ dropreg(counter)
    #_ dropreg(screen_char)
    #hlt $
        jmp @hlt

; compares two null terminated strings
; %20: str1
; %21: str2
; sets the Z bit of %F to 0 if equal and 1 if inequal. S bit gets modified.
; %20 and %21 now point to the strings with an offset of the length of the shorter one plus one
#STRCMP $
~@STRCMP
    #STRCMP_str1 "%20"
    #STRCMP_str2 "%21"
    #STRCMP_counter newreg()
    ; save state of used regs
    move @STRCMP_counter !

    #STRCMP_loop $
    ~@STRCMP_loop
        ; are the chars at the current pos equal?
        cmpu @STRCMP_str1 @STRCMP_str2
        jnz @STRCMP_end

        ; did str1 (and sine they are equal str2 aswell) have a null char and thus end?
        cmpu @STRCMP_str1 0u
        ; increment the str pointers
        addu @STRCMP_str1 1 @STRCMP_str1
        addu @STRCMP_str2 1 @STRCMP_str2
        ; jump if not null (cmpu a few lines above)
        jnz @STRCMP_loop

    #STRCMP_end $
    ~@STRCMP_end
        ; restore state of used regs and return
        ; %F Z bit should still be set
        move ! @STRCMP_counter 
        ret
    #_ dropreg(STRCMP_counter)

#DATA $ + 16
~@DATA
    #STR_16_BUF $
    . ascii "\0"*16

    #KEYBOARD_STR $
    . ascii "keyboard\0"

    #keyboard_id $
    . word 0
