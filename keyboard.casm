#SCREEN_BUF_1 0x00000000
#SCREEN_BUF_2 0x0003E800
#TEXT_BUF_1 0x0007D000
#TEXT_BUF_2 0x0007D400

#SCREEN_W 320
#SCREEN_H 200
#TEXT_W 40
#TEXT_H 25

#INTERRUPT 0x0008DE00
#START 0x0008E000

#regids [f'%{id:02X}' for id in range(49)]
#newreg lambda: regids.pop(0)
#dropreg lambda x: (regids.append(x), regids.sort())

~@INTERRUPT
    cmpu %Q 0
    jnz @handle
    ret
    #handle $
        pshar

        #event_ty newreg()
        #device_id newreg()
        and %Q 0b00001111_11111111_11111111_11111111 @device_id
        and %Q 0b11110000_00000000_00000000_00000000 @event_ty

        cmpu @event_ty 0b0000
        jz @device_connect
        cmpu @event_ty 0b0001
        cmpu @event_ty 0b0010
        cmpu @event_ty 0b0011

        #device_connect $
            dread @device_id @STR_16_BUF 16
            move @STR_16_BUF %20
            move @KEYBOARD_STR %21
            call @STRCMP
            jnz @finish_handling

        #device_disconnect $
            cmpu @keyboard_id @device_id
        jnz @KEYBOARD_STR

        cmpu @keyboard_id @device_id
        jnz @KEYBOARD_STR

        move @device_id @keyboard_id

    #finish_handling $
        resar
        ret
    #_ dropreg(event_ty)
    #_ dropreg(device_id)

~@START
    #counter newreg()
    #screen_char newreg()
    move 0u @counter
    move @TEXT_BUF_1 @screen_char 
    #loop $
        stb @screen_char @counter
        addu @screen_char 1 @screen_char
        addu @counter 1 @counter
        cmpu @counter 256
        jnz @loop
    #_ dropreg(counter)
    #_ dropreg(screen_char)
    #hlt $
        jmp @hlt

; compares two null terminated strings
; %20: str1
; %21: str2
; sets the Z bit of %F to 0 if equal and 1 if inequal. S bit gets modified.
; %20 and %21 now point to the strings with an offset of the length of the shorter one plus one
#STRCMP $
    #STRCMP_str1 "%20"
    #STRCMP_str2 "%21"
    #STRCMP_counter newreg()
    ; save state of used regs
    move @STRCMP_counter !

    #STRCMP_loop $
        ; are the chars at the current pos equal?
        cmpu @STRCMP_str1 @STRCMP_str2
        jnz @STRCMP_end

        ; did str1 (and sine they are equal str2 aswell) have a null char and thus end?
        cmpu @STRCMP_str1 0u
        ; increment the str pointers
        addu @STRCMP_str1 1 @STRCMP_str1
        addu @STRCMP_str2 1 @STRCMP_str2
        ; jump if not null (cmpu a few liens above)
        jnz @STRCMP_loop

    #STRCMP_end $
        ; restore state of used regs and return
        ; %F Z bit should still be set
        move ! @STRCMP_counter 
        ret
    #_ dropreg(STRCMP_counter)

#DATA $
    #STR_16_BUF $
    . ascii "\0"*16

    #KEYBOARD_STR $
    . ascii "keyboard\0"

    #keyboard_id $
    . word 0
